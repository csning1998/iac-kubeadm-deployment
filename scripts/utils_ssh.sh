#!/bin/bash

# This script contains general utility and helper functions.

readonly SSH_CONFIG="$HOME/.ssh/config"
readonly KNOWN_HOSTS_FILE="$HOME/.ssh/k8s_cluster_known_hosts"

# Function: Check if VMWare Workstation is installed
check_vmware_workstation() {
  # Check VMware Workstation
  if command -v vmware >/dev/null 2>&1; then
    vmware_version=$(vmware --version 2>/dev/null || echo "Unknown")
    echo "#### VMware Workstation: Installed (Version: $vmware_version)"
  else
    vmware_version="Not installed"
    echo "#### VMware Workstation: Not installed"
    echo "Prior to executing other options, registration is required on Broadcom.com to download and install VMWare Workstation Pro 17.5+."
    echo "Link: https://support.broadcom.com/group/ecx/my-dashboard"
    read -n 1 -s -r -p "Press any key to continue..."
    exit 1
  fi
}

# Function: Check if the required SSH private key exists
check_ssh_key_exists() {
  if [ -z "$SSH_PRIVATE_KEY" ]; then
      echo "#### Error: SSH_PRIVATE_KEY variable is not set."
      return 1
  fi

  if [ ! -f "$SSH_PRIVATE_KEY" ]; then
    echo "#### Error: SSH private key for automation not found at '$SSH_PRIVATE_KEY'"
    echo "#### Please use the 'Generate SSH Key' menu option first, or configure the correct key name in 'scripts/config.sh'."
    return 1
  fi
  # If the key exists, return success (0)
  return 0
}

# Function: Generate an SSH key for IaC automation (unattended mode)
generate_ssh_key() {
  local default_key_name="id_ed25519_iac_automation"
  local key_name

  echo "#### This utility will generate an SSH key for IaC automation (unattended mode)."
  read -p "#### Enter the desired key name (default: ${default_key_name}): " key_name
  
  key_name=${key_name:-$default_key_name}
  
  local private_key_path="${HOME}/.ssh/${key_name}"
  local public_key_path="${private_key_path}.pub"

  if [ -f "$private_key_path" ]; then
    echo "#### Warning: Key file '${private_key_path}' already exists."
    read -p "#### Overwrite? (y/n): " overwrite_answer
    if [[ ! "$overwrite_answer" =~ ^[Yy]$ ]]; then
      echo "#### Skipping key generation."
      return
    fi
  fi

  echo "#### Generating key at '${private_key_path}'..."
  ssh-keygen -t ed25519 -f "$private_key_path" -C "$key_name" -N ""
  
  echo "#### Key generated successfully:"
  ls -l "$private_key_path" "$public_key_path"
  echo "--------------------------------------------------"
  echo "#### IMPORTANT: Please update your configuration file"
  echo "####   e.g., in 'packer/secret.auto.pkrvars.hcl' or terraform/*.tfvars"
  echo "#### to use the following paths:"
  echo "In Terraform: ssh_private_key_path = \"${private_key_path}\""
  echo "In Packer: ssh_public_key_path  = \"${public_key_path}\""
  echo "--------------------------------------------------"
}

# Function: Verify SSH access to hosts defined in ~/.ssh/iac-kubeadm-deployment_config
verify_ssh() {
  echo ">>> STEP: Performing strict SSH access verification..."
  local ssh_config_file="$HOME/.ssh/iac-kubeadm-deployment_config"
  # This must match the file generated by bootstrap_ssh_known_hosts
  local known_hosts_file="$HOME/.ssh/k8s_cluster_known_hosts" 

  if [ ! -f "$ssh_config_file" ]; then
    echo "#### Error: SSH config file not found at $ssh_config_file"
    return 1
  fi
  if [ ! -f "$known_hosts_file" ]; then
    echo "#### Error: Known hosts file for cluster not found at $known_hosts_file"
    echo "#### Please ensure Terraform Stage I has completed successfully."
    return 1
  fi

  local all_hosts
  all_hosts=$(awk '/^Host / {print $2}' "$ssh_config_file")

  if [ -z "$all_hosts" ]; then
    echo "#### Error: No hosts found in $ssh_config_file"
    return 1
  fi

  # Loop through each host and test the connection silently.
  while IFS= read -r host; do
    if [ -z "$host" ]; then continue; fi
    
    local connected=false
    echo "#### Verifying connection to ${host}..."
    # Use ssh with the 'true' command for a quick, non-interactive connection test.
    # The '-n' option is CRITICAL here to prevent ssh from consuming the stdin of the while loop.
    for i in {1..15}; do
      if ssh -n \
          -F "$ssh_config_file" \
          -o ConnectTimeout=5 \
          -o BatchMode=yes \
          -o PasswordAuthentication=no \
          -o StrictHostKeyChecking=yes \
          -o UserKnownHostsFile="$known_hosts_file" \
        "$host" true 2>/dev/null; then
        echo "######## SUCCESS: Connected to ${host} via public key."
        connected=true
        break
      fi
      echo "    - Attempt $i failed for ${host}. Retrying in 2 seconds..."
      sleep 2
    done

    if [ $? -eq 0 ]; then
      echo "######## SUCCESS: Connected to ${host} via public key."
    else
      echo "######## FAILED: Could not connect to ${host} using strict key-based authentication."
    fi
  done <<< "$all_hosts"

  echo "#### SSH verification complete."
  echo "--------------------------------------------------"
}

# Function: Check if user wants to verify SSH connections
prompt_verify_ssh() {
  read -p "#### Do you want to verify SSH connections? (y/n): " answer
  if [[ "$answer" =~ ^[Yy]$ ]]; then
    verify_ssh
  else
    echo "#### Skipping SSH verification."
  fi
}

# Function: Prepend the Include directive to ~/.ssh/config for the k8s cluster
integrate_ssh_config() {
  # Default to ~/.ssh/config if not set, though it should be set by the caller.
  local ssh_config_file="${SSH_CONFIG:-$HOME/.ssh/config}"
  local k8s_config_path="$HOME/.ssh/iac-kubeadm-deployment_config"
  local include_line="Include $k8s_config_path"

  # Ensure the directory exists and config file exists
  mkdir -p "$(dirname "$ssh_config_file")" || {
    echo "Error: Failed to create directory $(dirname "$ssh_config_file")"
    return 1
  }

  touch "$ssh_config_file" || {
    echo "Error: Cannot touch $ssh_config_file"
    return 1
  }
  chmod 600 "$ssh_config_file"

  # Check if the Include line already exists in the file.
  if grep -Fxq "$include_line" "$ssh_config_file"; then
    echo "OK: '$include_line' already exists in $ssh_config_file."
    return 0
  fi

  echo "Action: Prepending '$include_line' to $ssh_config_file..."

  # Create a temporary file to safely build the new config
  local temp_file
  temp_file=$(mktemp) || {
    echo "Error: Failed to create temporary file."
    return 1
  }

  # Write the new Include line to the temporary file first.
  echo "$include_line" > "$temp_file" || {
    echo "Error: Failed to write to temporary file."
    rm "$temp_file"
    return 1
  }

  # Append the content of the original config file to the temporary file.
  cat "$ssh_config_file" >> "$temp_file" || {
    echo "Error: Failed to read from $ssh_config_file."
    rm "$temp_file"
    return 1
  }

  # Atomically replace the old config with the new one.
  mv "$temp_file" "$ssh_config_file" || {
    echo "Error: Failed to replace $ssh_config_file with the updated version."
    rm "$temp_file"
    return 1
  }

  # Re-apply strict permissions in case mv changed them
  chmod 600 "$ssh_config_file"
  echo "Success: SSH config updated."
}

# Function: Remove the Include directive from ~/.ssh/config for the k8s cluster
deintegrate_ssh_config() {
  if [[ -z "$SSH_CONFIG" ]]; then
    echo "Error: SSH_CONFIG is not defined"
    exit 1
  fi

  local include_line="Include $HOME/.ssh/iac-kubeadm-deployment_config"
  if [[ -f "$SSH_CONFIG" ]]; then
    echo "Removing '$include_line' from $SSH_CONFIG"
    sed -i "\|$include_line|d" "$SSH_CONFIG" || {
      echo "Error: Failed to remove line from $SSH_CONFIG"
      exit 1
    }
  else
    echo "Warning: $SSH_CONFIG does not exist, skipping removal"
  fi
}

bootstrap_ssh_known_hosts() {
  if [ $# -eq 0 ]; then
    echo "#### Error: No IP addresses provided to bootstrap_ssh_known_hosts."
    return 1
  fi
  
  echo ">>> Preparing for Ansible: Clearing old host keys and scanning new ones..."
  mkdir -p "$HOME/.ssh"
  rm -f "$KNOWN_HOSTS_FILE"
  
  echo "#### Scanning host keys for all nodes..."
  # Iterate through all IP address parameters passed from `terraform/modules/ansible/main.tf`
  for ip in "$@"; do
    echo "#### Waiting for SSH on ${ip} to be ready..."
    for i in {1..30}; do # Wait for up to 30 seconds
      if ssh-keyscan -H "$ip" >> "$KNOWN_HOSTS_FILE" 2>/dev/null; then
        echo "      - Scanned key for ${ip}"
        break
      fi
      if [ "$i" -eq 30 ]; then
        echo "#### Error: Timed out waiting for SSH on ${ip}."
        return 1
      fi
      sleep 1
    done
  done
  
  echo "#### Host key scanning complete. File created at $KNOWN_HOSTS_FILE"
  echo "--------------------------------------------------"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  if [[ $# -eq 0 ]]; then
    echo "Error: No function specified"
    exit 1
  fi
  "$@"
fi

# Function: Report execution time
report_execution_time() {
  local END_TIME DURATION MINUTES SECONDS
  END_TIME=$(date +%s)
  DURATION=$((END_TIME - START_TIME))
  MINUTES=$((DURATION / 60))
  SECONDS=$((DURATION % 60))
  echo "--------------------------------------------------"
  echo ">>> Execution time: ${MINUTES}m ${SECONDS}s"
  echo "--------------------------------------------------"
}
