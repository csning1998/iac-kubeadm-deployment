#!/bin/bash

# (Dev) This function is for faster reset and re-execute the Ansible Playbook
apply_ansible_stage_II(){
  echo ">>> STEP: Rebuild the VM Environment of Stage II..."

  local private_key_path="${SSH_PRIVATE_KEY}"
  local relative_inventory_path="ansible/inventory.yaml"
  local relative_playbook_reset="ansible/playbooks/90-reset-cluster.yaml"
  local relative_playbook_provision="ansible/playbooks/10-provision-cluster.yaml"

  # Define the playbook commands
  local cmd_reset="ansible-playbook \
    -i ${relative_inventory_path} \
    --private-key ${private_key_path} \
    -vv \
    ${relative_playbook_reset}"

  local cmd_provision="ansible-playbook \
    -i ${relative_inventory_path} \
    --private-key ${private_key_path} \
    -vv \
    ${relative_playbook_provision}"

  echo "#### [DEV] Running Playbook: 90-reset-cluster.yaml"
  run_command "${cmd_reset}" "${SCRIPT_DIR}"

  echo "#### [DEV] Running Playbook: 10-provision-cluster.yaml"
  run_command "${cmd_provision}" "${SCRIPT_DIR}"
}

# Function: Format Ansible JSON output into a readable summary (with ONLY verbosity set to 2 )
# Generated by Google Gemini 2.5 Pro
format_ansible_output() {
  jq -r '
  # Helper to recursively parse string-encoded JSON.
  def parse_nested_json:
    walk(
      # ONLY try to parse strings that LOOK like JSON (start with { or [)
      if type == "string" and test("^\\s*(\\{|\\[)") then
        try fromjson catch . # If it looks like JSON but fails, keep the original string
      else
        . # Keep non-string or non-JSON-like strings as they are
      end
    );

  # Helper to format specific multi-line string fields into string arrays.
  def format_multiline_strings:
    (if .msg? and (.msg | type) == "string" then .msg |= split("\n") else . end) |
    (if .stdout? and (.stdout | type) == "string" then .stdout |= split("\n") else . end)
    ;

  to_entries[] | (
    .key + ":",
    (
      .value | split("\n") | .[] |
      select(test("^(TASK|PLAY RECAP|ok:|changed:|failed:)")) |
      if test(" => \\{") then
        (split(" => ")[0] + " =>"),
        (split(" => ")[1] | fromjson | parse_nested_json | format_multiline_strings)
      else
        .
      end
    ),
    ""
  )
  '
}
